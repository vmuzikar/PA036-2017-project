#!/usr/local/bin/tclsh8.6
if [catch {package require Thread} ] { error "Failed to load Thread library" }
if [catch {package require Pgtcl} ] { error "Failed to load Pgtcl - Postgres Library Error" }

#EDITABLE OPTIONS##################################################
set total_iterations  ;# Number of transactions before logging off
set RAISEERROR "false" ;# Exit script on PostgreSQL (true or false)
set KEYANDTHINK "false" ;# Time for user thinking and keying (true or false)
set ora_compatible "false" ;#Postgres Plus Oracle Compatible Schema
set host "localhost" ;# Address of the server hosting PostgreSQL
set port "5432" ;# Port of the PostgreSQL Server
set user "tpcc";# PostgreSQL user
set password "tpcc" ;# Password for the PostgreSQL user
set db "tpcc" ;# Database containing the TPC Schema
#EDITABLE OPTIONS##################################################

#RANDOM NUMBER
proc RandomNumber {m M} {return [expr {int(+rand()*(+1-))}]}

#NURand function
proc NURand { iConst x y C } {return [ expr {((([RandomNumber 0 ] | [RandomNumber  ]) + ) % ( -  + 1)) +  }]}

#RANDOM NAME
proc randname { num } {
    array set namearr { 0 BAR 1 OUGHT 2 ABLE 3 PRI 4 PRES 5 ESE 6 ANTI 7 CALLY 8 ATION 9 EING }
    set name [ concat ([ expr {(  / 100 ) % 10 }])([ expr {(  / 10 ) % 10 }])([ expr {(  / 1 ) % 10 }]) ]
    return 
}

#TIMESTAMP
proc gettimestamp { } {
set tstamp [ clock format [ clock seconds ] -format %Y%m%d%H%M%S ]
    return 
}
#KEYING TIME
proc keytime { keying } {
    after [ expr { * 1000} ]
    return
}
#THINK TIME
proc thinktime { thinking } {
    set thinkingtime [ expr {abs(round(log(rand()) * ))} ]
    after [ expr { * 1000} ]
    return
}
#POSTGRES CONNECTION
proc ConnectToPostgres { host port user password dbname } {
    global tcl_platform
    if {[catch {set lda [pg_connect -conninfo [list host =  port =  user =  password =  dbname =  ]]}]} {
        puts stderr "Error, the database connection to  could not be established"
        set lda "Failed"
    } else {
    if {(platform) == "windows"} {
            #Workaround for Bug #95 where first connection fails on Windows
            catch {pg_disconnect }
            set lda [pg_connect -conninfo [list host =  port =  user =  password =  dbname =  ]]
        }
        pg_notice_handler  puts
        set result [ pg_exec  "set CLIENT_MIN_MESSAGES TO 'ERROR'" ]
        pg_result  -clear
    }
    return 
}
#NEW ORDER
proc neword { lda no_w_id w_id_input RAISEERROR ora_compatible } {
    #2.4.1.2 select district id randomly from home warehouse where d_w_id = d_id
    set no_d_id [ RandomNumber 1 10 ]
    #2.4.1.2 Customer id randomly selected where c_d_id = d_id and c_w_id = w_id
    set no_c_id [ RandomNumber 1 3000 ]
    #2.4.1.3 Items in the order randomly selected from 5 to 15
    set ol_cnt [ RandomNumber 5 15 ]
    #2.4.1.6 order entry date O_ENTRY_D generated by SUT
    set date [ gettimestamp ]
    if {  eq "true" } {
    set result [pg_exec  "exec neword(,,,,,0,TO_TIMESTAMP(,'YYYYMMDDHH24MISS'))" ]
    } else {
    set result [pg_exec  "select neword(,,,,,0)" ]
    }
    if {[pg_result  -status] != "PGRES_TUPLES_OK"} {
        if {  } {
            error "[pg_result  -error]"
        } else {
            puts "New Order Procedure Error set RAISEERROR for Details"
            }
    } else {
        puts "New Order:      0 [ pg_result  -list ]"
        pg_result  -clear
    }
}
#PAYMENT
proc payment { lda p_w_id w_id_input RAISEERROR ora_compatible } {
    #2.5.1.1 The home warehouse id remains the same for each terminal
    #2.5.1.1 select district id randomly from home warehouse where d_w_id = d_id
    set p_d_id [ RandomNumber 1 10 ]
    #2.5.1.2 customer selected 60% of time by name and 40% of time by number
    set x [ RandomNumber 1 100 ]
    set y [ RandomNumber 1 100 ]
    if {  <= 85 } {
        set p_c_d_id 
        set p_c_w_id 
    } else {
        #use a remote warehouse
        set p_c_d_id [ RandomNumber 1 10 ]
        set p_c_w_id [ RandomNumber 1  ]
        while { ( == ) && ( != 1) } {
        set p_c_w_id [ RandomNumber 1   ]
        }
    }
    set nrnd [ NURand 255 0 999 123 ]
    set name [ randname  ]
    set p_c_id [ RandomNumber 1 3000 ]
    if {  <= 60 } {
        #use customer name
        #C_LAST is generated
        set byname 1
    } else {
        #use customer number
        set byname 0
        set name {}
    }
    #2.5.1.3 random amount from 1 to 5000
    set p_h_amount [ RandomNumber 1 5000 ]
    #2.5.1.4 date selected from SUT
    set h_date [ gettimestamp ]
    #2.5.2.1 Payment Transaction
    #change following to correct values
    if {  eq "true" } {
        set result [pg_exec  "exec payment(,,,,,,,'','0',0,TO_TIMESTAMP(,'YYYYMMDDHH24MISS'))" ]
    } else {
        set result [pg_exec  "select payment(,,,,,,,'','0',0)" ]
    }
    if {[pg_result  -status] != "PGRES_TUPLES_OK"} {
    if {  } {
        error "[pg_result  -error]"
                } else {
        puts "Payment Procedure Error set RAISEERROR for Details"
            }
        } else {
        puts "Payment:         0 0 [ pg_result  -list ]"
        pg_result  -clear
	}
}
#ORDER_STATUS
proc ostat { lda w_id RAISEERROR ora_compatible } {
    #2.5.1.1 select district id randomly from home warehouse where d_w_id = d_id
    set d_id [ RandomNumber 1 10 ]
    set nrnd [ NURand 255 0 999 123 ]
    set name [ randname  ]
    set c_id [ RandomNumber 1 3000 ]
    set y [ RandomNumber 1 100 ]

    if {  <= 60 } {
        set byname 1
    } else {
        set byname 0
        set name {}
    }
    
    if {  eq "true" } {
        set result [pg_exec  "exec ostat(,,,,'')" ]
    } else {
        set result [pg_exec  "select * from ostat(,,,,'') as (ol_i_id NUMERIC,  ol_supply_w_id NUMERIC, ol_quantity NUMERIC, ol_amount NUMERIC, ol_delivery_d TIMESTAMP,  out_os_c_id INTEGER, out_os_c_last VARCHAR, os_c_first VARCHAR, os_c_middle VARCHAR, os_c_balance NUMERIC, os_o_id INTEGER, os_entdate TIMESTAMP, os_o_carrier_id INTEGER)" ]
    }

    if {[pg_result  -status] != "PGRES_TUPLES_OK"} {
        if {  } {
            error "[pg_result  -error]"
        } else {
            puts "Order Status Procedure Error set RAISEERROR for Details"
        }
    } else {
        puts "Order Status:      [ pg_result  -list ]"
        pg_result  -clear
    }
}
#DELIVERY
proc delivery { lda w_id RAISEERROR ora_compatible } {
set carrier_id [ RandomNumber 1 10 ]
set date [ gettimestamp ]
if {  eq "true" } {
set result [pg_exec  "exec delivery(,,TO_TIMESTAMP(,'YYYYMMDDHH24MISS'))" ]
} else {
set result [pg_exec  "select delivery(,)" ]
}
if {[pg_result  -status] ni {"PGRES_TUPLES_OK" "PGRES_COMMAND_OK"}} {
if {  } {
error "[pg_result  -error]"
		} else {
puts "Delivery Procedure Error set RAISEERROR for Details"
		}
	} else {
puts "Delivery:   [ pg_result  -list ]"
pg_result  -clear
	}
}
#STOCK LEVEL
proc slev { lda w_id stock_level_d_id RAISEERROR ora_compatible } {
    set threshold [ RandomNumber 10 20 ]
    if {  eq "true" } {
    set result [pg_exec  "exec slev(,,)" ]
    } else {
    set result [pg_exec  "select slev(,,)" ]
    }
    if {[pg_result  -status] ni {"PGRES_TUPLES_OK" "PGRES_COMMAND_OK"}} {
    if {  } {
    error "[pg_result  -error]"
            } else {
    puts "Stock Level Procedure Error set RAISEERROR for Details"
            }
        } else {
    puts "Stock Level:    [ pg_result  -list ]"
    pg_result  -clear
        }
}
#RUN TPC-C

set lda [ ConnectToPostgres      ]

if {  eq "Failed" } {
    error "error, the database connection to  could not be established"
 } else {
    if {  eq "true" } {
        set result [ pg_exec  "exec dbms_output.disable" ]
        pg_result  -clear
	}
 }

pg_select  "select max(w_id) from warehouse" w_id_input_arr {
    set w_id_input (max)
	}

#2.4.1.1 set warehouse_id stays constant for a given terminal
set w_id  [ RandomNumber 1  ]  
pg_select  "select max(d_id) from district" d_id_input_arr {
    set d_id_input (max)
}

set stock_level_d_id  [ RandomNumber 1  ]  
puts "Processing  transactions without output suppressed..."

set abchk 1; 
set abchk_mx 1024; 
set hi_t [ expr {pow([ lindex [ time {if {  [ tsv::get application abort ]  } { break }} ] 0 ],2)}]

for {set it 0} { < } {incr it} 
{
    if { [expr { % }] eq 0 } 
    { 
        if { [ time {if {  [ tsv::get application abort ]  } { break }} ] >  }  
            {  set  abchk [ expr {min(( * 2), )}]; 
            set hi_t [ expr { * 2} ] } 
    }

    set choice [ RandomNumber 1 23 ]

    if { <= 10} {
        puts "new order"
        if {  } { keytime 18 }
        neword     
        if {  } { thinktime 12 }

    } elseif { <= 20} {
        puts "payment"
        if {  } { keytime 3 }
        payment     
        if {  } { thinktime 12 }

    } elseif { <= 21} {
        puts "delivery"
        if {  } { keytime 2 }
        delivery    
        if {  } { thinktime 10 }

    } elseif { <= 22} {
    puts "stock level"
        if {  } { keytime 2 }
        slev     
        if {  } { thinktime 5 }

    } elseif { <= 23} {
        puts "order status"
        if {  } { keytime 2 }
        ostat    
        if {  } { thinktime 5 }
    }
}

pg_disconnect 